---
title: Node初识
---

# Node 初识

## 简介

NodeJS 遵循`ECMAScript`语法规范和`CommonJS`模块规范

NodeJS = `ECMAScript` + `NodeJS API` + `Web API`

可以处理 HTTP，处理文件等

## 安装

### nvm 安装

## NodeJS 需要注意

### 服务端稳定性

能够持续稳定的运行

### CPU 和内存为稀缺资源

尽可能的去压缩服务端对资源的消耗

### 日志记录

日志记录是整个系统的实时监控，排错都靠它

### 安全

预防越权操作，预防 XSS 攻击和 sql 注入等等

### 负荷

集群拆分和服务拆分：应对流量过大，导致服务器负荷的问题

## CommonJS 模块规范

> NodeJS 应用由模块组成，采用的`commonJS`模块规范
> 每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见
> `CommonJS`规范规定，每个模块内部，`module`变量代表当前模块
> 这个变量是一个对象，它的`exports`属性（即`module.exports`）是对外的接口。加载某个模块，其实是加载该模块的`module.exports`属性。`require`方法用于加载模块

- 使用 `exports`、`module.exports` 来导出成员
- 使用 `require` 来导入成员
- 程序默认情况下 `var exports = module.exports`

### exports 使用方法

```js
// index2.js
const a = 'Hello Word';
exports.a = a;
// index.js
const a = require('./index2');
console.log(a); // { a: 'Hello Word' }
```

### module.exports 使用方法

```js
// index2.js
let obj = {
  name: 'mtr',
  age: 18,
};
module.exports = obj;
// index.js
const obj = require('./index2');
console.log(obj); // { name: 'mtr', age: 18 }
```

## ES6 模块规范

- 使用 `export`、`export default` 来导出成员
- 使用 `import moduleName from 'module'` 来导入成员

> 注意：
> NodeJS 是遵循 CommonJS 模块规范的，不是 ES6 模块规范
> 要使用 ES6 模块规范，需要`npm init`，在生成的`package.json`中，添加`"type": "module"`

### export 使用方法

> `export` 导出的成员，在导入的时候必须使用 `import { xxx } from './xxx'` 带大括号

```js
// index2.js
export let m = 1;
// index.js
import { m } from './index2.js';
console.log(m); // 1

// index2.js
const m = 1;
export { m };
// index.js
import { m } from './index2.js';
console.log(m); // 1

// index2.js
let n = 1;
export { n as m };
// index.js
import { m } from './index2.js';
console.log(m); // 1
```

### export default 使用方法

```js
// index2.js
export default function () {
  return 1 + 3;
}
// index.js
import one from './index2.js';
console.log(one()); // 4
```

## 文件模块类型

三种类型：

- js 文件模块：以下 JS 文件模块导入示例只是单向访问 A—>B
- json 文件模块：JSON 不需要导出，只导入即可
- node 文件模块：Node 文件模块是二进制文件，需要编译生成的，无法自己创建

#### 注意事项

1. 每个模块文件都是一个私有空间，默认都无法互相访问
2. 导出在 A，导入在 B
3. `module.exports`存数据，`require`只能写相对路径
4. module 是 Node.js 中的全局对象，所有模块都是 Module 的实例，载入一个模块就是构建一个 Module 实例

Node 内部提供一个`Module全局对象`，其属性如下：

```js
Module {
  id: '.',  // 模块的标识符，主模块的id属性值为“.”，其他模块的id属性值为该模块文件的绝对路径
  exports: {}, // 模块的导出对象，为require加载时提供返回结果
  parent: null, // 当前模块的父模块
  filename: '', // 当前模块的文件名称和存储路径
  loaded: false, // 表示模块是否加载完成
  children: [], // 当前模块的子模块
  paths:[] // 加载模块文件的路径顺序
}
```

## NodeJS 核心模块

比如：HTTP 模块，URL 模块

## NodeJS 自定义模块

比如：用户手写的模块

1. 使用 `npm init -y `来初始化自定义模块
2. 直接在文件中`引入成员`（引入接口）即可

```js
let result = require('相对路径');
console.log(result);
```

## NodeJS 第三方模块

比如：通过 npm 来远程下载的模块

> 如果是文件夹模块，`require`指定所需的文件夹名称（模块名称）即可
> 指定文件夹模块时，文件夹内`必须`存在`xxx.js`入口文件或`package.json`文件
> 当文件夹模块中都有`xxx.js`和`package.json`文件时，优先执行`package.json`文件
> 执行`package.json`文件时，会读取`"main": "xxx.js"`来加载入口文件

关于`package.json`文件，格式如下：

```json
{
  "name": "模块名",
  "version": "模块版本",
  "description": "模块描述",
  "main": "模块的入口文件",
  "dependencies": {
    "生产依赖的名称": "版本"
  },
  "devDependencies": {
    "开发依赖的名称": "版本"
  },
  "scripts": {
    "命令名": "echo 模块的执行命令"
  },
  "keywords": ["模块的关键字"],
  "author": "模块的作者",
  "license": "模块的开源协议，如：ISC、MIT"
}
```

列如：

```js
// node_modules/axios/index.js
let obj = {
  name: 'mtr',
  age: 18,
  get: function () {
    console.log('获取用户数据');
    return 1;
  },
  set: function () {
    console.log('响应用户数据');
  },
  qiqi: Number(null),
};
module.exports = obj;

// index.js
const axios = require('axios'); // 默认会寻找node_modules/axios中的index.js
console.log(axios);
```

## 模块执行顺序

引入模块时的查找顺序：

.js —> .json —> .node —> package.json —> xxx.js

加载模块时的查找顺序：

核心模块 —> 第三方模块 —>自定义模块
