---
title: JavaScript内置对象
---

# JavaScript 内置对象

## window 对象方法

### window.location 对象

:::tip
`window.location` 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。window.location 对象在编写时可不使用 window 这个前缀。
:::

```js
location.hostname; // 返回 web 主机的域名
location.pathname; // 返回当前页面的路径和文件名
location.origin; // 返回 https://www.xxxxxxxx.com
location.port; // 返回 web 主机的端口 （80 或 443）
location.protocol; // 返回所使用的 web 协议（http:// 或 https://）
window.location.href = 'xxx'; // 跳转后有后退功能
window.location.replace('xxx'); // 跳转后没有后退功能
window.open('xxx'); // 在新的窗口打开链接，一般用于简单的弹出页面
window.location.reload(); // 刷新当前页面
parent.location.reload(); // 刷新父亲对象（用于框架）
opener.location.reload(); // 刷新父窗口对象（用于单开窗口）
top.location.reload(); // 刷新最顶端对象（用于多开窗口）
```

### window.history 对象

:::tip
`window.history` 对象包含浏览器的历史。window.history 对象在编写时可不使用 window 这个前缀。
:::

```js
window.history.back(); // 加载历史列表中的前一个URL，与在浏览器点击后退按钮相同，
window.history.forward(); // 加载历史列表中的下一个URL。 与在浏览器中点击按钮向前相同
```

### window.navigator 对象

- `window.navigator` 对象包含有关访问者浏览器的信息，对象在编写时可不使用 window 这个前缀
- 来自 `navigator` 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为:
- navigator 数据可被浏览器使用者更改
- 一些浏览器对测试站点会识别错误
- 浏览器无法报告晚于浏览器发布的新操作系统

```js
window.navigator.appCodeName // 返回浏览器的代码名。
window.navigator.appName // 返回代表浏览器名的字符串。
window.navigator.appMinorVersion // 返回浏览器的次版本号。该属性是一个只读的字符串。仅IE有效。
window.navigator.userAgent // 返回代表浏览器名和版本号的字符串。
window.navigator.platform // 返回浏览器平台的字符串（"Win32", "Win16", "WinCE", "Mac68k", "MacPPC", "HP-UX", "SunOS" 等）。
window.navigator.cpuClass // 返回CPU的信息（"x86", "68K", "Alpha", "PPC" 等）。仅IE有效。
window.navigator.browserLanguage // 返回浏览器的语言种类。仅IE有效。
window.navigator.systemLanguage // 返回系统的语言种类。仅IE有效。
window.navigator.userLanguage userLanguage // 返回用户环境的语言种类。仅IE有效。
window.navigator.cookieEnabled // 返回 cookie 是否可用的真伪值。
window.navigator.onLine // 返回是否能连上网络的真伪值。
window.navigator.javaEnabled() // 返回 Java 是否可用的真伪值。
window.navigator.userProfile // 保存着用户信息的对象。拥有 addReadRequest() doReadRequest() getAttribute() clearRequest() 等方法。
window.navigator.taintEnabled() // 是否可以加密数据的真伪值。仅IE有效。
```

### window 其它方法

```js
window.setInterval(); // 间隔指定的毫秒数不停地执行指定的代码。
window.setTimeout(); // 暂停指定的毫秒数后执行指定的代码
window.clearInterval(); // 方法用于停止 setInterval() 方法执行的函数代码。
window.clearTimeout(); // 方法用于停止执行setTimeout()方法的函数代码。
window.alert(); // 警告框
window.prompt(); // 确认框
window.confirm(); // 输入框
window.open(); // 打开新窗口，第二个参数_self表示当前窗口，_blank表示新窗口，_parent表示父窗口，_top表示顶层窗口。
window.close(); // 关闭当前窗口
window.moveTo(); // 移动当前窗口
window.resizeTo(); // 调整当前窗口的尺寸
window.frameElement; // 获取当前文档的宿主节点iframe元素
window.execScript(); // execScript函数与eval的功能相同，不同的是eval函数执行后的脚本的作用域是当前执行上下文，而execScript则总是针对全局作用域。
```

## JS 禁止 DOM 方法

使用 `return false` 可以实现禁用原生的方法

### 禁止右键

```html
<div oncontextmenu="return false"></div>
```

### 禁止复制和剪切元素

```html
<div oncopy="return false"></div>
<div oncut="return false"></div>
```

### 禁止选中元素

```html
<div onselectstart="return false"></div>
```

### 禁止拖动元素

```html
<div ondragstart="return false"></div>
```

### 小常识

- Vue 的 `axios` 中只有 `get` 和 `delete` 传递参数时需要使用 params 对象，其他直接传对象即可，或者直接传递 reast 参数
- 使用 `async` 和 `await` 的时候 `async` 必须要在当前作用域的函数前面进行修饰
- `axios` 的拦截器 axios.interceptors.request.use，必须要传一个 config 参数并返回，否则报错，request 是请求
- CORS 策略已经阻止了从起源 `http://localhost:8080` 访问 XMLHttpRequest at 'xxxxxxx'。请求的资源上没有'Access-Control-Allow-Origin'头？，这个问题时而有时而没有，与后端也不存在跨域的问题
  - 原因：被防火墙识别为恶意访问，拦截掉了
- 当清除计时器时传递某个计时器的变量会较为准确，如果不传递某个计时器的变量，默认会清除所有计时器
- `null` 取反为 `true`
- 当一个元素 `blur` 的时候一定会优先触发 `mousedown` 事件，原因：Mousedown 事件是当鼠标按下时触发
- mouseover 和 mouseout 在父元素和其子元素都可以触发，当鼠标穿过一个元素时，触发次数得依子元素数量而言。
- mouseenter 和 mouseleave 只在父元素触发，当鼠标穿过一个元素时，只会触发一次。
- mouseover 和 mouseout 比 mouseenter 和 mouseleave 先触发

## 工具函数

### Base64 转 File

```js
function base64ToFile(urlData: string, filename: any) {
  if (typeof urlData !== 'string') return;
  const arr: any = urlData.split(',');
  const type = arr[0].match(/:(.*?);/)[1];
  const extension = type.split('/')[1];
  const bstr = atob(arr[1]);
  let len = bstr.length;
  const u8arr = new Uint8Array(len);
  while (len--) {
    u8arr[len] = bstr.charCodeAt(len);
  }
  return new File([u8arr], `${filename}.${extension}`, { type });
}
```

### 数组递归扁平化

```js
export const recursionFlat = (target: any[], init: any[] = []): any => {
  target.forEach((item: any) => {
    item.children?.length || delete item.children;
    item.id && init.push(item);
    item.children && recursionFlat(item.children, init);
  });
  return init;
};
```

### 数组递归改变每个元素

```js
function disableCheckbox(target: any[]) {
  target.forEach((item: any) => {
    item.disableCheckbox = true;
    item.children && disableCheckbox(item.children);
  });
  return target;
}
```

### 压缩图片

```js
import Compressor from 'compressorjs';
/**
 * @param image 图片
 * @param backType 需要返回的类型blob,file
 * @param quality 图片压缩比 0-1,数字越小，图片压缩越小
 * @returns
 */
export const compressorImage = (image, backType, quality) => {
  return new Promise((resolve, reject) => {
    new Compressor(image, {
      quality: quality || 0.8,
      success(result) {
        let file = new File([result], image.name, { type: image.type });

        if (!backType || backType == 'blob') {
          resolve(result);
        } else if (backType == 'file') {
          resolve(file);
        } else {
          resolve(file);
        }
      },
      error(err) {
        console.log('图片压缩失败---->>>>>', err);
        reject(err);
      },
    });
  });
};

// 将 Base64 转换为文件
const imgFile = base64ToFile(base64, 'certificate');
// 压缩图片
const file = await compressorImage(imgFile, 'file', 0.6);
```
